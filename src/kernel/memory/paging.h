#pragma once

#include <stdbool.h>
#include <stdint.h>

typedef enum {
    PAGE_FLAG_GLOBAL = 1 << 8,
    PAGE_FLAG_SIZE_4MIB = 1 << 7,
    PAGE_FLAG_SIZE_4KIB = 0,
    PAGE_FLAG_USER = 1 << 2, 
    PAGE_FLAG_SUPERVISOR = 0,
    PAGE_FLAG_READ_WRITE = 1 << 1,
    PAGE_FLAG_READ_ONLY = 0,
} PagingFlags;

/**
 * @brief Initializes paging so that we know where out virtual memory should begin for allocation functions, and to plug a 64KiB hole in memory that is
 * left unmapped.
 * @param p_phys_mem_start The position at which to being allocating physical memory. The hole in question requires 64KiB, so we need to add that into
 * our calculations first and here is the best position for that.
 */
void paging_initialize(uint32_t *p_phys_mem_start);

/**
 * @brief Maps a range of physical memory to that of a specified virtual memory. Use this function only when the output address is known (i.e. framebuffers)
 * and never any other time, see `paging_allocate_region`.
 * @param p_physical The physical starting memory address
 * @param p_virtual The desired virtual starting memory address
 * @param p_size The number of bytes to directly map. Higher numbers (ideally multiples of 4096) should be used.
 * @return `true` if the function succeeded, and `false` if it was unable to map the area. 
 */
bool paging_map_region(uint32_t p_physical, uint32_t p_virtual, uint32_t p_size);

/**
 * @brief Allocates N 4KiB blocks of virtual memory to the given memory range. Should be used in most cases of memory allocation where the user knows
 * what physical memory is available but not what virtual memory is.
 * @param p_address The starting physical address
 * @param p_size The number of bytes to map. Multiples of 4096 should be used.
 * @return The allocated virtual memory address if successful. NULL on failure. NOTE: Failing on NULL should be regarded as a potential kernel panic
 * situation, as there is no more virtual memory available to allocate, and the moron maintainer who limited the allocated pages to 255 because of
 * space requirements should be notified of this and have their stupid-ass code updated to take care of this issue.
 */
void *paging_allocate_region(uint32_t p_address, uint32_t p_size);

/**
 * @brief Frees the data associated to the given handle. Handles should not be created manually as they are generated by `paging_map_region()`.
 * @param p_handle The handle to the page table to modify.
 */
void paging_free_region(uint32_t p_virtual, uint32_t p_size);

/**
 * @brief Converts a mapped virtual address to a physical one.
 * @param p_address The address to convert
 * @return The physical address, or 0 if the address couldn't be found. Since the BIOS is identity-mapped, please don't use it for that.
 */
uint32_t virtual_to_physical(uint32_t p_address);

/**
 * @brief Converts a physical address to its mapped counterpart, if it exists.
 * @param p_address The (physical) address to convert
 * @return The virtual address, or 0 if the physical address doesn't map correctly. 
 */
uint32_t physical_to_virtual(uint32_t p_address);

/**
 * @brief Checks to see if the given virtual address has a mapped physical address.
 * @param p_virtual The address to check for
 * @return `true` if yes, `false` if no.
 */
bool is_valid_address(void *p_virtual);

/**
 * @brief Checks to see if the given virtual address range is usable. Normally used in conjunction with other paging functions to map a range if needed
 * @param p_start The start address in the range
 * @param p_end The end address in the range
 * @return `true` if yes, `false` if no.
 */
bool is_valid_range(void *p_start, void *p_end);
