#pragma once

#include <stdbool.h>
#include <stdint.h>

typedef enum {
    PAGE_FLAG_GLOBAL = 1 << 8,
    PAGE_FLAG_SIZE_4MIB = 1 << 7,
    PAGE_FLAG_SIZE_4KIB = 0,
    PAGE_FLAG_USER = 1 << 2, 
    PAGE_FLAG_SUPERVISOR = 0,
    PAGE_FLAG_READ_WRITE = 1 << 1,
    PAGE_FLAG_READ_ONLY = 0,
} PagingFlags;

/**
 * @brief Maps a range of physical memory to that of a specified virtual memory. 
 * @param p_physical 
 * @param p_virtual 
 * @param p_size 
 * @return 
 */
bool paging_map_region(void *p_physical, void *p_virtual, uint32_t p_size);

/**
 * @brief Frees the data associated to the given handle. Handles should not be created manually as they are generated by `paging_map_region()`.
 * @param p_handle The handle to the page table to modify.
 */
void paging_free_region(void *p_virtual, uint32_t p_size);

/**
 * @brief Converts a mapped virtual address to a physical one.
 * @param p_address The address to convert
 * @return The physical address, or 0 if the address couldn't be found. Since the BIOS is identity-mapped, please don't use it for that.
 */
uint32_t virtual_to_physical(uint32_t p_address);

/**
 * @brief Checks to see if the given virtual address has a mapped physical address.
 * @param p_virtual The address to check for
 * @return `true` if yes, `false` if no.
 */
bool is_valid_address(void *p_virtual);

/**
 * @brief Checks to see if the given virtual address range is usable. Normally used in conjunction with other paging functions to map a range if needed
 * @param p_start The start address in the range
 * @param p_end The end address in the range
 * @return `true` if yes, `false` if no.
 */
bool is_valid_range(void *p_start, void *p_end);
